package cs2030s.fp;

import java.util.ArrayList;
import java.util.List;

public class InfiniteList<T> {
  private Memo<Actually<T>> head;
  private Memo<InfiniteList<T>> tail;
  private static final InfiniteList<Object> END = new End();

  private InfiniteList(Memo<Actually<T>> head, Memo<InfiniteList<T>> tail) {
    this.head = head;
    this.tail = tail;
  }
  // You may add other private constructor but it's not necessary.

  public static <T> InfiniteList<T> generate(Constant<T> prod) {
    return new InfiniteList<T>(
        Memo.<Actually<T>>from(() -> Actually.ok(prod.init())),
        Memo.<InfiniteList<T>>from(() -> generate(prod))
        );
  }

  public static <T> InfiniteList<T> iterate(T seed, Immutator<T, T> func) {
    return new InfiniteList<T>(
        Memo.<Actually<T>>from(Actually.ok(seed)),
        Memo.<InfiniteList<T>>from(() -> iterate(func.invoke(seed), func))
        );
  }

  public T head() {
    return this.head.get().except(() -> this.tail.get().head());
  }

  public InfiniteList<T> tail() {
    return this.head.get().transform(x -> this.tail.get()).except(() -> this.tail.get().tail());
  }

  public <R> InfiniteList<R> map(Immutator<? extends R, ? super T> f) {
    return new InfiniteList<R>(
        Memo.<Actually<R>>from(() -> Actually.ok(f.invoke(this.head()))),
        Memo.<InfiniteList<R>>from(() -> this.tail().map(f))
        );
  }

  public InfiniteList<T> filter(Immutator<Boolean, ? super T> pred) {
    return new InfiniteList<T>(
        Memo.<Actually<T>>from(() -> this.head.get().check(pred)),
        Memo.<InfiniteList<T>>from(() -> this.tail.get().filter(pred))
        );
  }

  public InfiniteList<T> limit(long n) {
    if (n <= 0) {
      return InfiniteList.end();
    }
    return new InfiniteList<T>(
        Memo.<Actually<T>>from(() -> Actually.<T>ok(this.head())),
        Memo.<InfiniteList<T>>from(() -> this.tail().limit(n - 1))
        );
  }

  public InfiniteList<T> takeWhile(Immutator<Boolean, ? super T> pred) {
    // TODO
    return new InfiniteList<>(null, null);
  }

  public List<T> toList() {
    ArrayList<T> list = new ArrayList<T>();
    InfiniteList<T> cur = this;
    while (!cur.isEnd()) {
      list.add(cur.head());
      cur = cur.tail();
    }
    return list;
  }

  public <U> U reduce (U id, Combiner<U, U, ? super T> acc) {
    // TODO
    return null;
  }


  public long count() {
    // TODO
    return 0L;
  }

  @Override
  public String toString() {
    return "[" + this.head + " " + this.tail + "]";
  }

  public boolean isEnd() {
    return false;
  }

  public static <R> InfiniteList<R> end() {
    @SuppressWarnings("unchecked")
    InfiniteList<R> ans = (InfiniteList<R>) InfiniteList.END;
    return ans;
  }


  // Add your End class here...

  private static class End extends InfiniteList<Object> {
    protected End() {
      super(null, null);
    }

    @Override
    public Object head() {
      throw new java.util.NoSuchElementException();
    }

    @Override
    public InfiniteList<Object> tail() {
      throw new java.util.NoSuchElementException();
    }

    @Override
    public <R> InfiniteList<R> map(Immutator<? extends R, ? super Object> f) {
      return super.<R>end();
    }

    @Override
    public InfiniteList<Object> filter(Immutator<Boolean, ? super Object> pred) {
      return super.<Object>end();
    }

    @Override 
    public boolean isEnd() {
      return true;
    }

    @Override
    public String toString() {
      return "-";
    }
  }
}
